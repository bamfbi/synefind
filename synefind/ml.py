
class autoencoder:

    def __init__(
            self
            ): 
        # big ol pass
        pass

    def load_analyzed_signals(
            self,
            signal_directory_name
            ):

        #load the signals
        self.signals = [None]

        # exit code 
        return 0


    def process_signals(
            self
            ):
        # some kind of processing to the signal to 
        # augment them // make them usable for ml 
        self.signals = self.signals
        
        # exit code 
        return 0

    def train(
            self, 
            architecture=(100,50,10,50,100),
            epochs=10,
            regularization=True
            ):
        # reeeeally far from implementing. will train our autoencoder
        # once that all has been implemented. top down look at it tho. 
        training_parameters = [None]

        # probably this will be a manipulation of many utility classes, 
        # defined further down in this repository. TBD. 
        # utilityclass.blabla

        # save the trained model
        # save(blabla) 
       
        # exit code
        return 0

    def evaluate(
            self,
            evaluation_signal
            ):
        # some kind of evaluation of an evaluation signal. Check it out boys. 
        autoencoder_parameters = evaluation_signal
        return autoencoder_parameters


